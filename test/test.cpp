
#include <iostream>
#include <intrin.h>
#include<Windows.h>
#include"include/capstone/capstone.h"

using namespace std;

__int64 key = 0x1234567812345678;
//CmpAppendDllSection函数大小为184个字节，也就是0xB8,八字节对齐为0xC0
//说明pg可能是8字节加密一次
#pragma section text
unsigned char CmpAppendDllSection[0xc0] =
{
    0x2e,0x48,0x31,0x11,
    0x48,0x31,0x51,0x08,
    0x48,0x31,0x51,0x10,
    0x48,0x31,0x51,0x18,
    0x48,0x31,0x51,0x20,
    0x48,0x31,0x51,0x28,
    0x48,0x31,0x51,0x30,
    0x48,0x31,0x51,0x38,
    0x48,0x31,0x51,0x40,
    0x48,0x31,0x51,0x48,
    0x48,0x31,0x51,0x50,
    0x48,0x31,0x51,0x58,
    0x48,0x31,0x51,0x60,
    0x48,0x31,0x51,0x68,
    0x48,0x31,0x51,0x70,
    0x48,0x31,0x51,0x78,
    0x48,0x83,0xC1,0x78,
    0x48,0x31,0x51,0x08,
    0x48,0x31,0x51,0x10,
    0x48,0x31,0x51,0x18,
    0x48,0x31,0x51,0x20,
    0x48,0x31,0x51,0x28,
    0x48,0x31,0x51,0x30,
    0x48,0x31,0x51,0x38,
    0x48,0x31,0x51,0x40,
    0x48,0x31,0x51,0x48,
    0x48,0x83,0xE9,0x78,
    0x31,0x11,
    0x48,0x8B,0xC2,
    0x48,0x8B,0xD1,
    0x8B,0x8A,0xC4,0x00,0x00,0x00,
    0x48,0x85,0xC0,
    0x74,0x11,
    0x48,0x31,0x84,0xCA,0xC0,0x0,0x0,0x0,
    0x48,0xD3,0xC8,
    0x48,0x0F,0xBB,0xC0,
    0xE2,0xEF,
    0x8B,0x82,0xD0,0x7,0,0,
    0x48,0x3,0xc2,
    0x48,0x83,0xEc,0x28,
    0xff,0xd0,
    0x48,0x83,0xc4,0x28,
    0x4c,0x8b,0x80,0x8,0x1,0,0,
    0x48,0x8D,0x88,0x80,0x07,00,00,
    0xba,0x1,0,0,0,
    0x41,0xff,0xe0,0,0,0,0,0,0,0
};

int main()
{
    csh handle;
    cs_insn* insn;
    size_t count;
    if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle)) {
        printf("ERROR: Failed to initialize engine!\n");
        return -1;
    }   
    cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);
    
    /*++++++++++++++++++++++
    * 
    win7就像下面那行代码只有一层加密
    明 xor key = 密
    也就是 key = 明 xor 密
    明文我们是知道的，就是IDA看到的，密文我们不知道，存在于内存的某个地方。
    我们拿所有可执行内存池的内存做碰撞，但是win10后面就不行了，win10的这里并不是一层xor加密，
    也就是说你至少得先解密出第一层，再用win7的方法，然后根据资料看也不现实，pg加密方法太多
    但是他后面的context只有一层加密

    -----------------------*/

    for (LONGLONG* p = (LONGLONG*)CmpAppendDllSection;; p++)
    {
        if (p == (LONGLONG*)((LONGLONG)CmpAppendDllSection + sizeof(CmpAppendDllSection)))
            break;
        InterlockedXor64(p, key);
        
    }

    //CmpAppendDllSection[0] = 0x2E;
    //CmpAppendDllSection[1] = 0x48;
    //CmpAppendDllSection[2] = 0x31;
    //CmpAppendDllSection[3] = 0x11;

    InterlockedXor64((LONGLONG*)&CmpAppendDllSection[0], *(LONGLONG*)&CmpAppendDllSection[8]);

    cout << hex << (LONGLONG*)&CmpAppendDllSection[0];

#if 0
    int insCount = 0;
    while (1) {
        cs_disasm(handle, (const uint8_t*)CmpAppendDllSection + insCount, 0x20,
            (uint64_t)CmpAppendDllSection, 0, &insn);
        insCount += insn->size;
        cout << insn->mnemonic << " " << insn->op_str << endl;
        if (insCount >= sizeof(CmpAppendDllSection))
            break;
    }
#endif

    getchar();
    return 0;
}


